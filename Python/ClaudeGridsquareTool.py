#MIT License, code generated by AI.
#!/usr/bin/env python3
"""
Maidenhead Grid Square Distance Calculator

Calculates the great circle distance between two Maidenhead grid squares
using the Haversine formula.
"""

import math
from typing import Tuple


class GridSquare:
    """Maidenhead Grid Square utilities"""
    
    @staticmethod
    def to_latlon(grid: str) -> Tuple[float, float]:
        """
        Convert Maidenhead grid square to latitude/longitude
        
        Args:
            grid: Maidenhead grid square (e.g., 'FN42hn', 'JO01', etc.)
                  Supports 2, 4, 6, or 8 character grid squares
        
        Returns:
            Tuple of (latitude, longitude) in decimal degrees
        
        Raises:
            ValueError: If grid square format is invalid
        """
        grid = grid.strip().upper()
        
        if len(grid) not in [2, 4, 6, 8]:
            raise ValueError(f"Grid square must be 2, 4, 6, or 8 characters, got {len(grid)}")
        
        # Validate format
        if not (grid[0:2].isalpha()):
            raise ValueError(f"First two characters must be letters: {grid}")
        if len(grid) >= 4 and not grid[2:4].isdigit():
            raise ValueError(f"Characters 3-4 must be digits: {grid}")
        if len(grid) >= 6 and not grid[4:6].isalpha():
            raise ValueError(f"Characters 5-6 must be letters: {grid}")
        if len(grid) == 8 and not grid[6:8].isdigit():
            raise ValueError(f"Characters 7-8 must be digits: {grid}")
        
        # Field (first 2 characters): 20° longitude, 10° latitude
        lon = (ord(grid[0]) - ord('A')) * 20 - 180
        lat = (ord(grid[1]) - ord('A')) * 10 - 90
        
        if len(grid) >= 4:
            # Square (characters 3-4): 2° longitude, 1° latitude
            lon += int(grid[2]) * 2
            lat += int(grid[3]) * 1
        
        if len(grid) >= 6:
            # Subsquare (characters 5-6): 5' longitude, 2.5' latitude
            lon += (ord(grid[4]) - ord('A')) * (2/24)
            lat += (ord(grid[5]) - ord('A')) * (1/24)
        
        if len(grid) == 8:
            # Extended square (characters 7-8): 30" longitude, 15" latitude
            lon += int(grid[6]) * (2/240)
            lat += int(grid[7]) * (1/240)
        
        # Return center of the grid square
        if len(grid) == 2:
            lon += 10  # Center of 20° field
            lat += 5   # Center of 10° field
        elif len(grid) == 4:
            lon += 1   # Center of 2° square
            lat += 0.5 # Center of 1° square
        elif len(grid) == 6:
            lon += (1/24)  # Center of 5' subsquare
            lat += (1/48)  # Center of 2.5' subsquare
        elif len(grid) == 8:
            lon += (1/240) # Center of 30" extended square
            lat += (1/480) # Center of 15" extended square
        
        return (lat, lon)
    
    @staticmethod
    def distance(grid1: str, grid2: str, unit: str = 'km') -> float:
        """
        Calculate great circle distance between two grid squares
        
        Args:
            grid1: First Maidenhead grid square
            grid2: Second Maidenhead grid square
            unit: Distance unit - 'km', 'mi' (miles), or 'nm' (nautical miles)
        
        Returns:
            Distance in specified units
        """
        lat1, lon1 = GridSquare.to_latlon(grid1)
        lat2, lon2 = GridSquare.to_latlon(grid2)
        
        # Earth's radius
        R_km = 6371.0
        R_mi = 3959.0
        R_nm = 3440.0
        
        # Convert to radians
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        dLat = math.radians(lat2 - lat1)
        dLon = math.radians(lon2 - lon1)
        
        # Haversine formula
        a = (math.sin(dLat/2) ** 2 + 
             math.cos(lat1_rad) * math.cos(lat2_rad) * 
             math.sin(dLon/2) ** 2)
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        
        if unit.lower() in ['km', 'kilometers', 'kilometres']:
            return R_km * c
        elif unit.lower() in ['mi', 'miles']:
            return R_mi * c
        elif unit.lower() in ['nm', 'nautical', 'nauticalmiles']:
            return R_nm * c
        else:
            raise ValueError(f"Unknown unit: {unit}. Use 'km', 'mi', or 'nm'")
    
    @staticmethod
    def bearing(grid1: str, grid2: str) -> float:
        """
        Calculate initial bearing from grid1 to grid2
        
        Args:
            grid1: Starting grid square
            grid2: Destination grid square
        
        Returns:
            Bearing in degrees (0-360, where 0/360 is North)
        """
        lat1, lon1 = GridSquare.to_latlon(grid1)
        lat2, lon2 = GridSquare.to_latlon(grid2)
        
        # Convert to radians
        lat1_rad = math.radians(lat1)
        lat2_rad = math.radians(lat2)
        dLon = math.radians(lon2 - lon1)
        
        # Calculate bearing
        x = math.sin(dLon) * math.cos(lat2_rad)
        y = (math.cos(lat1_rad) * math.sin(lat2_rad) - 
             math.sin(lat1_rad) * math.cos(lat2_rad) * math.cos(dLon))
        
        bearing = math.atan2(x, y)
        bearing_degrees = math.degrees(bearing)
        
        # Normalize to 0-360
        return (bearing_degrees + 360) % 360


def format_distance(km: float) -> str:
    """Format distance in multiple units"""
    mi = km * 0.621371
    nm = km * 0.539957
    return f"{km:,.1f} km ({mi:,.1f} mi, {nm:,.1f} nm)"


def format_bearing(bearing: float) -> str:
    """Format bearing with cardinal direction"""
    directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE',
                  'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW']
    index = round(bearing / 22.5) % 16
    return f"{bearing:.1f}° ({directions[index]})"


def main():
    """Example usage and interactive mode"""
    print("=" * 70)
    print("Maidenhead Grid Square Distance Calculator")
    print("=" * 70)
    print()
    
    # Example calculations
    examples = [
        ("FN42", "JO01", "Boston area to London area"),
        ("FN42hn", "DM13at", "Massachusetts to Arizona"),
        ("CN87", "CN88", "Adjacent grid squares"),
        ("JN25", "QF22", "Europe to Australia"),
    ]
    
    print("Example Calculations:")
    print("-" * 70)
    
    for grid1, grid2, description in examples:
        try:
            dist = GridSquare.distance(grid1, grid2, 'km')
            bearing = GridSquare.bearing(grid1, grid2)
            lat1, lon1 = GridSquare.to_latlon(grid1)
            lat2, lon2 = GridSquare.to_latlon(grid2)
            
            print(f"\n{description}")
            print(f"  From: {grid1:8} ({lat1:7.3f}°, {lon1:8.3f}°)")
            print(f"  To:   {grid2:8} ({lat2:7.3f}°, {lon2:8.3f}°)")
            print(f"  Distance: {format_distance(dist)}")
            print(f"  Bearing:  {format_bearing(bearing)}")
        except ValueError as e:
            print(f"\n{description}: Error - {e}")
    
    print("\n" + "=" * 70)
    print("Interactive Mode")
    print("=" * 70)
    print("Enter two grid squares to calculate distance (or 'quit' to exit)")
    print()
    
    while True:
        try:
            grid1 = input("Grid square 1: ").strip()
            if grid1.lower() in ['quit', 'exit', 'q']:
                break
            
            grid2 = input("Grid square 2: ").strip()
            if grid2.lower() in ['quit', 'exit', 'q']:
                break
            
            # Calculate distance and bearing
            dist_km = GridSquare.distance(grid1, grid2, 'km')
            bearing = GridSquare.bearing(grid1, grid2)
            back_bearing = GridSquare.bearing(grid2, grid1)
            
            # Get coordinates
            lat1, lon1 = GridSquare.to_latlon(grid1)
            lat2, lon2 = GridSquare.to_latlon(grid2)
            
            print()
            print("-" * 70)
            print(f"From: {grid1.upper():8} ({lat1:7.3f}°, {lon1:8.3f}°)")
            print(f"To:   {grid2.upper():8} ({lat2:7.3f}°, {lon2:8.3f}°)")
            print(f"\nDistance:     {format_distance(dist_km)}")
            print(f"Bearing:      {format_bearing(bearing)}")
            print(f"Back Bearing: {format_bearing(back_bearing)}")
            print("-" * 70)
            print()
            
        except ValueError as e:
            print(f"Error: {e}\n")
        except KeyboardInterrupt:
            print("\nExiting...")
            break
        except EOFError:
            break


if __name__ == '__main__':
    main()
